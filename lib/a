import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'Orby/OrbyIntroScreen.dart';

class EstudosScreen extends StatefulWidget {
  const EstudosScreen({super.key});

  @override
  State<EstudosScreen> createState() => _EstudosScreenState();
}

class _EstudosScreenState extends State<EstudosScreen> {
  int _currentStep = 0;
  String? objetivoEstudo;
  final Map<String, dynamic> respostas = {};
  final Map<String, TextEditingController> controllers = {
    "outro": TextEditingController(),
    "experiencia": TextEditingController(),
    "motivacao": TextEditingController(),
    "dataProva": TextEditingController(),
    "curso": TextEditingController(),
    "nivel": TextEditingController(),
  };
  DateTime? dataProva;

  final objetivos = [
    'Vestibular/Enem',
    'Faculdade',
    'Concurso',
    'Certifica√ß√£o',
    'Aprendizado Pessoal'
  ];

  final estilosAprendizado = ['Visual', 'Auditivo', 'Cinest√©sico', 'Leitura/Escrita'];
  final turnos = ['Manh√£', 'Tarde', 'Noite'];
  final diasSemana = ['1 dia', '2 dias', '3 dias', '4 dias', '5 dias', '6 dias', 'Todos os dias'];

  void _nextStep() => setState(() => _currentStep++);

  Future<Map<String, List<String>>> buscarConteudos() async {
    final db = FirebaseFirestore.instance;
    final materias = await db.collection('Estudo').get();
    final Map<String, List<String>> conteudosPorMateria = {};

    for (final doc in materias.docs) {
      final materia = doc.id;
      final subcollection = await db.collection('Estudo').doc(materia).collection(materia).get();

      if (subcollection.docs.isEmpty) {
        print("‚ö†Ô∏è Sem subtemas encontrados para $materia");
      } else {
        print("‚úÖ Subtemas encontrados para $materia:");
        subcollection.docs.forEach((d) => print("- ${d.id}"));
      }

      conteudosPorMateria[materia] = subcollection.docs.map((d) => d.id).toList();
    }

    print("üìö Conte√∫dos final: $conteudosPorMateria");
    return conteudosPorMateria;
  }



  Future<void> gerarPlanoEstudos(Map<String, List<String>> conteudos) async {
    final prompt = StringBuffer();
    prompt.writeln("Voc√™ √© um organizador de planos de estudo para vestibulares.");
    prompt.writeln("Crie um plano de estudos semanal completo com base nos conte√∫dos abaixo.");
    prompt.writeln("Inclua TODAS as mat√©rias e seus respectivos subtemas listados.");
    prompt.writeln("Organize o conte√∫do em 4 semanas, com 5 dias de estudo por semana, distribuindo bem os assuntos.");
    prompt.writeln("Varie as mat√©rias por dia e n√£o repita os mesmos t√≥picos.");
    prompt.writeln("Retorne a resposta APENAS em JSON estruturado como abaixo:");
    prompt.writeln("{ 'Semana 1': { 'Mat√©ria': ['Subtema1', 'Subtema2'] }, 'Semana 2': {...}, 'Semana 3': {...}, 'Semana 4': {...} }");
    prompt.writeln("Conte√∫dos dispon√≠veis:");
    conteudos.forEach((materia, topicos) {
      prompt.writeln("Mat√©ria: $materia");
      prompt.writeln("T√≥picos: ${topicos.join(', ')}\n");
    });

    // üîé Print no terminal antes do envio
    print("üìö Mat√©rias e conte√∫dos enviados para a API:");
    conteudos.forEach((materia, topicos) {
      print("Mat√©ria: $materia");
      print("T√≥picos: ${topicos.join(', ')}\n");
    });

    // üîê SUA CHAVE DIRETA AQUI (substitua depois por vari√°vel de ambiente)
    const String apiKey = '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';

    final response = await http.post(
      Uri.parse('https://api.openai.com/v1/chat/completions'),
      headers: {
        'Authorization': 'Bearer $apiKey',
        'Content-Type': 'application/json',
      },
      body: jsonEncode({
        "model": "gpt-3.5-turbo",
        "messages": [
          {"role": "user", "content": prompt.toString()}
        ],
        "temperature": 0.7
      }),
    );

    final data = jsonDecode(response.body);

    if (data['choices'] == null || data['choices'].isEmpty) {
      print('‚ùå Erro da OpenAI: ${data['error'] ?? 'Resposta vazia'}');
      throw Exception('Erro ao gerar plano de estudos');
    }

    final content = data['choices'][0]['message']['content'];
    final cleanJson = content.replaceAll(RegExp(r'```json|```'), '').trim();
    final planoJson = jsonDecode(cleanJson);

    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid != null) {
      await FirebaseFirestore.instance
          .collection("usuarios")
          .doc(uid)
          .collection("Objetivo")
          .doc("Estudos")
          .set({
        "Tipo": "Estudos",
        "PlanoGerado": planoJson,
      }, SetOptions(merge: true));
    }
  }



  Future<void> _salvarRespostas() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    await FirebaseFirestore.instance.collection("usuarios").doc(uid).collection("Objetivo").doc("Estudos").set({
      "Tipo": "Estudos",
      "Perguntas": respostas,
    });

    if (respostas['Objetivo'] == 'Vestibular/Enem') {
      final conteudos = await buscarConteudos();
      await gerarPlanoEstudos(conteudos);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Plano de estudos gerado e salvo com sucesso!")),
        );
      }
    } else {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Respostas salvas com sucesso!")),
        );
        Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) => const OrbyIntroScreen()));
      }
    }
  }

  Widget _buildCustomQuestion() {
    if (_currentStep == 0) {
      return _buildLabeledOptions(
        'Voc√™ estuda para qual tipo de objetivo?',
        objetivos,
        objetivoEstudo,
            (val) {
          setState(() {
            objetivoEstudo = val;
            respostas['Objetivo'] = val;
            _currentStep = 0;
          });
        },
      );
    }

    switch (_currentStep) {
      case 1:
        return _buildLabeledOptions('Qual seu estilo de aprendizado preferido?', estilosAprendizado, respostas['estilo'], (val) => setState(() => respostas['estilo'] = val));
      case 2:
        return _buildTextField('Qual seu n√≠vel atual de conhecimento?', 'nivel');
      case 3:
        return _buildLabeledOptions('Qual melhor turno para voc√™ estudar?', turnos, respostas['turno'], (val) => setState(() => respostas['turno'] = val));
      case 4:
        return _buildLabeledOptions('Quantos dias por semana voc√™ pode estudar?', diasSemana, respostas['dias'], (val) => setState(() => respostas['dias'] = val));
      case 5:
        return _buildLabeledOptions('Voc√™ prefere revisar ou simular quest√µes?', ['Revisar', 'Simular', 'Ambos'], respostas['preferencia'], (val) => setState(() => respostas['preferencia'] = val));
    }

    return const SizedBox();
  }

  Widget _buildLabeledOptions(String pergunta, List<String> options, String? selected, Function(String) onSelected) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(pergunta, style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)),
        const SizedBox(height: 12),
        ...options.map((opt) => Container(
          margin: const EdgeInsets.symmetric(vertical: 6),
          width: double.infinity,
          child: ElevatedButton(
            onPressed: () => onSelected(opt),
            style: ElevatedButton.styleFrom(
              backgroundColor: selected == opt ? Colors.blue : Colors.transparent,
              side: const BorderSide(color: Colors.white),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(40)),
              padding: const EdgeInsets.symmetric(vertical: 14),
            ),
            child: Text(opt, style: const TextStyle(color: Colors.white)),
          ),
        ))
      ],
    );
  }

  Widget _buildTextField(String label, String key) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        TextField(
          controller: controllers[key],
          onChanged: (val) => respostas[key] = val,
          decoration: _inputDecoration(label),
          style: const TextStyle(color: Colors.white),
        )
      ],
    );
  }

  InputDecoration _inputDecoration(String label) {
    return InputDecoration(
      labelText: label,
      labelStyle: const TextStyle(color: Colors.white),
      filled: true,
      fillColor: Colors.white12,
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(40)),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0D1A2B),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            children: [
              Row(
                children: [
                  Image.asset('assets/images/orby_semtxt.png', height: 70),
                  const SizedBox(width: 8),
                  const Text('Orbyt', style: TextStyle(color: Colors.white, fontSize: 30, fontWeight: FontWeight.bold)),
                ],
              ),
              const SizedBox(height: 40),
              Expanded(
                child: SingleChildScrollView(
                  keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
                  child: _buildCustomQuestion(),
                ),
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    if (_currentStep < 5) {
                      _nextStep();
                    } else {
                      _salvarRespostas();
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF4A90E2),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(40)),
                  ),
                  child: Text(
                    _currentStep < 5 ? "Pr√≥ximo" : "Finalizar",
                    style: const TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
